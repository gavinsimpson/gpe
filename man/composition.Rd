% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kernel_comp.R, R/kernel_sugar.R
\docType{methods}
\name{composition}
\alias{*.kernel}
\alias{+.kernel}
\alias{\%x\%}
\alias{^.kernel}
\alias{composition}
\alias{kronecker,kernel,kernel-method}
\alias{prod.kernel}
\alias{sum.kernel}
\title{Compositional kernels}
\usage{
\method{sum}{kernel}(..., na.rm = FALSE)

\method{+}{kernel}(kernel1, kernel2)

\method{prod}{kernel}(..., na.rm = FALSE)

\method{*}{kernel}(kernel1, kernel2)

\method{^}{kernel}(kernel, power)

\S4method{kronecker}{kernel,kernel}(X, Y, FUN = "*", make.dimnames = FALSE,
  ...)

kernel1 \%x\% kernel2
}
\arguments{
\item{na.rm}{an unused argument for consistency with the generic sum
function}

\item{kernel, kernel1, kernel2, X, Y}{kernel objects to be combined}

\item{power}{an integer (or integer-esque numeric) giving the power to which
to raise the kernel function. If \code{power} is not integer-esque (that is
\code{power != round(power)}) a warning is issued and the power rounded.}

\item{FUN}{the operation to use in the kronecker operation, included only
for compatability, FUN = "*" is used regardless of what's specified}

\item{make.dimnames}{included only for compatability, ignored here}

\item{\dots}{several kernel objects to be combined}
}
\value{
A kernel object for which there are a range of associated functions, see \code{\link{kernel}} and \code{\link{access}} for details.
}
\description{
Construct a new kernel by combining existing kernels, either 
by summation, multiplication or the kronecker product.

Summation and multiplication require that the covariance matrices produced
the two kernels have the same dimension (same number of rows in the input
columns) and result in a kernel with the same dimension as its inputs.

The kronecker product doesn't require that the input functions have the 
same dimension, and the dimension of the output is the product of the 
dimensions of the inputs (i.e. an m-by-m matrix kroneckered with an 
n-by-n matrix gives rise to an nm-by-nm matrix).
}
\examples{

# construct a kernel with one feature
k1 <- rbf('temperature')

# and another with two features
k2 <- rbf(c('temperature', 'pressure'))


# sum lots of kernels
k_sum <- sum(k1, k2, k1)

# evaluate the function and look at the matrix
image(k_sum(pressure))
 

# sum two kernels
k_1p2 <- k1 + k2

# evaluate the function and look at the matrix
image(k_1p2(pressure))
 

# multiply lots of kernels
k_prod <- prod(k1, k2, k1)

# evaluate the function and look at the matrix
image(k_prod(pressure))
 

# multiply two kernels
k_1_2 <- k1 * k2

# evaluate the function and look at the matrix
image(k_1_2(pressure))
 
# get a cubic kernel
k <- int() + lin('pressure', c = 400, sigma = 0.003)
k_cu <- k ^ 3

# evaluate the function and look at the matrix
image(k_cu(pressure))

# look at example draws from the original and cubed kernel
demoKernel(k, pressure) 
demoKernel(k_cu, pressure) 
 

# get the kronecker product of two kernels
k_kron <- kronecker(k1, k2)

# evaluate the function and look at the matrix
image(k_kron(pressure))
 

# get the kronecker product of two kernels more elegantly
k_kron <- k1 \%x\% k2

# evaluate the function and look at the matrix
image(k_kron(pressure))
 
}
\seealso{
Other kernel.constructors: \code{\link{expo}},
  \code{\link{iid}}, \code{\link{int}}, \code{\link{lin}},
  \code{\link{mat32}}, \code{\link{mat52}},
  \code{\link{per}}, \code{\link{rbf}}, \code{\link{rq}}
}

